# IronRose 핫 리로드 전략 변경

## 변경 날짜
2026-02-13

## 기존 전략의 문제점

### Phase 2A: 엔진 코드 핫 리로드
```
Engine DLL 자체를 핫 리로드
→ ALC로 언로드/재로드
→ 복잡한 상태 관리 필요
→ 타입 격리 문제 (Renderer, Scene 등)
```

**문제점**:
1. **상태 보존의 복잡성**: 엔진 전체를 언로드하면 렌더링 상태, 씬 그래프, 리소스 등 모든 것을 직렬화/복원해야 함
2. **타입 격리 문제**: Veldrid, Window 등 네이티브 리소스를 가진 타입들의 마샬링 어려움
3. **디버깅 어려움**: ALC 경계를 넘나드는 버그 추적 힘듦
4. **안정성 저하**: 엔진 코어가 불안정해지면 전체 시스템 다운

---

## 새로운 전략: 플러그인 기반 핫 리로드

### 핵심 개념

```
┌─────────────────────────────────────┐
│  IronRose.Engine (안정적인 코어)     │
│  - 핫 리로드 대상 아님                │
│  - 플러그인 진입점 제공                │
│  - 안정적인 기반 기능                 │
└─────────────────────────────────────┘
              ↓ 플러그인 API
┌─────────────────────────────────────┐
│  Game.dll / Plugins (핫 리로드)      │
│  - 게임 로직                          │
│  - 엔진 확장 기능                     │
│  - 런타임 코드 인젝션                 │
└─────────────────────────────────────┘
```

### 1단계: 플러그인 시스템 설계

#### 플러그인 진입점 (Engine 제공)

```csharp
// IronRose.Engine/Plugin/IEnginePlugin.cs
public interface IEnginePlugin
{
    string Name { get; }
    string Version { get; }

    // 생명주기
    void OnLoad(IEngine engine);
    void OnUnload();

    // 엔진 훅
    void OnPreUpdate(float deltaTime);
    void OnPostUpdate(float deltaTime);
    void OnPreRender(IRenderer renderer);
    void OnPostRender(IRenderer renderer);

    // 씬 훅
    void OnSceneLoad(IScene scene);
    void OnSceneUnload(IScene scene);

    // GameObject 훅
    void OnGameObjectCreated(IGameObject gameObject);
    void OnGameObjectDestroyed(IGameObject gameObject);
}

// 플러그인 매니저
public class PluginManager
{
    private List<IEnginePlugin> _plugins = new();
    private AssemblyLoadContext _pluginContext;

    public void LoadPlugin(string dllPath)
    {
        // ALC로 플러그인만 격리
        _pluginContext = new AssemblyLoadContext("PluginContext", isCollectible: true);
        var assembly = _pluginContext.LoadFromAssemblyPath(dllPath);

        // 플러그인 인스턴스 생성
        var pluginType = assembly.GetTypes()
            .FirstOrDefault(t => typeof(IEnginePlugin).IsAssignableFrom(t));

        var plugin = (IEnginePlugin)Activator.CreateInstance(pluginType);
        plugin.OnLoad(_engine);
        _plugins.Add(plugin);
    }

    public void UnloadPlugin(string name)
    {
        var plugin = _plugins.FirstOrDefault(p => p.Name == name);
        plugin?.OnUnload();
        _plugins.Remove(plugin);

        _pluginContext.Unload();
        GC.Collect();
        GC.WaitForPendingFinalizers();
    }

    public void HotReload()
    {
        // 1. 기존 플러그인 언로드
        foreach (var plugin in _plugins.ToList())
        {
            UnloadPlugin(plugin.Name);
        }

        // 2. 재빌드
        RebuildPlugins();

        // 3. 재로드
        LoadPlugins();
    }
}
```

#### 엔진 확장 API (Engine 제공)

```csharp
// IronRose.Engine/Plugin/IEngine.cs
public interface IEngine
{
    IRenderer Renderer { get; }
    ISceneManager SceneManager { get; }
    IResourceManager Resources { get; }

    // 커스텀 컴포넌트 등록
    void RegisterComponent<T>() where T : IComponent;

    // 커스텀 렌더러 등록
    void RegisterRenderPass(IRenderPass pass);

    // 이벤트 시스템
    void Subscribe<TEvent>(Action<TEvent> handler);
    void Publish<TEvent>(TEvent eventData);
}
```

### 2단계: 게임 로직 플러그인

```csharp
// Game/Plugins/GameplayPlugin.cs
public class GameplayPlugin : IEnginePlugin
{
    public string Name => "Gameplay";
    public string Version => "1.0.0";

    private IEngine _engine;

    public void OnLoad(IEngine engine)
    {
        _engine = engine;

        // 커스텀 컴포넌트 등록
        engine.RegisterComponent<PlayerController>();
        engine.RegisterComponent<EnemyAI>();

        // 이벤트 구독
        engine.Subscribe<CollisionEvent>(OnCollision);

        Console.WriteLine("[Plugin] Gameplay loaded");
    }

    public void OnPreUpdate(float deltaTime)
    {
        // 게임 로직 업데이트
        UpdatePlayerInput();
        UpdateAI();
    }

    public void OnPreRender(IRenderer renderer)
    {
        // 커스텀 렌더링 (UI, 디버그 그래픽 등)
        DrawDebugInfo(renderer);
    }

    private void OnCollision(CollisionEvent evt)
    {
        Console.WriteLine($"[Plugin] Collision: {evt.A} <-> {evt.B}");
    }
}
```

### 3단계: AI Digest 시스템

#### 실행 후 통합 프로세스

```
┌─────────────────────────────────────┐
│  1. 런타임 코딩 & 테스트              │
│     - 플러그인으로 기능 구현           │
│     - 핫 리로드로 빠른 반복            │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│  2. AI Digest 과정                   │
│     - 플러그인 코드 분석               │
│     - 사용자 선택 (어떤 기능 통합?)    │
│     - 엔진 코드 생성/수정              │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│  3. 엔진 통합                         │
│     - 플러그인 코드 → 엔진 코드 병합   │
│     - 단위 테스트 생성                 │
│     - 문서화                          │
└─────────────────────────────────────┘
```

#### AI Digest 명령 파일

```json
// .claude/digest_commands.json
{
  "digest": {
    "plugin": "GameplayPlugin",
    "version": "1.0.0",
    "features_to_integrate": [
      {
        "name": "PlayerController",
        "action": "integrate",
        "target": "src/IronRose.Engine/Components/PlayerController.cs"
      },
      {
        "name": "EnemyAI",
        "action": "keep_plugin",
        "reason": "아직 실험적"
      },
      {
        "name": "CustomRenderPass",
        "action": "integrate",
        "target": "src/IronRose.Engine/Rendering/CustomRenderPass.cs"
      }
    ]
  }
}
```

#### AI Agent 자동화 스크립트

```python
# .claude/digest_automation.py
def digest_plugin(plugin_path, commands_path):
    """
    플러그인을 분석하고 엔진에 통합
    """
    # 1. 플러그인 코드 읽기
    plugin_code = read_plugin(plugin_path)

    # 2. 명령 파일 읽기
    commands = read_json(commands_path)

    # 3. 각 기능 처리
    for feature in commands['features_to_integrate']:
        if feature['action'] == 'integrate':
            # AI가 엔진 코드로 변환
            engine_code = convert_to_engine_code(
                plugin_code,
                feature['name']
            )

            # 타겟 위치에 작성
            write_file(feature['target'], engine_code)

            # 단위 테스트 생성
            generate_unit_tests(feature['target'])

            # 문서 업데이트
            update_documentation(feature['name'])

    # 4. 검증
    run_tests()
    build_engine()

    # 5. 보고서 생성
    generate_digest_report()
```

---

## 장점

### 1. 안정성
- ✅ 엔진 코어는 항상 안정적
- ✅ 플러그인 크래시가 엔진 전체에 영향 없음
- ✅ 복잡한 상태 관리 불필요

### 2. 개발 속도
- ✅ 플러그인 핫 리로드는 훨씬 빠름 (작은 DLL)
- ✅ 엔진 재컴파일 불필요
- ✅ 빠른 반복 개발 가능

### 3. 확장성
- ✅ 모듈러 아키텍처
- ✅ 서드파티 플러그인 지원 가능
- ✅ 기능별 독립적 개발

### 4. AI 워크플로우 최적화
- ✅ 런타임 실험 → 검증된 기능만 통합
- ✅ 점진적 엔진 개선
- ✅ 자동화된 통합 프로세스

---

## 단점

### 1. 플러그인 API 설계 필요
- ⚠️ 어떤 진입점을 제공할지 설계 필요
- ⚠️ API 변경 시 플러그인 호환성 문제
- **해결책**: 초기에 핵심 훅만 제공, 점진적 확장

### 2. 성능 오버헤드
- ⚠️ 플러그인 호출에 약간의 오버헤드
- **해결책**: 크리티컬 패스는 엔진에 통합, 실험적 기능만 플러그인

### 3. AI Digest 과정의 복잡도
- ⚠️ 플러그인 코드 → 엔진 코드 변환 로직 필요
- **해결책**: 템플릿 기반 변환, 점진적 개선

---

## 구현 로드맵

### Phase 2B: 플러그인 시스템 구현 (새로운 Phase)

**목표**: 엔진 핫 리로드를 플러그인 시스템으로 대체

#### 1단계: 플러그인 인프라 (1-2일)
- [ ] `IEnginePlugin` 인터페이스 정의
- [ ] `PluginManager` 구현
- [ ] 플러그인 생명주기 관리
- [ ] 플러그인 ALC 격리

#### 2단계: 엔진 확장 API (2-3일)
- [ ] `IEngine` 인터페이스 설계
- [ ] 컴포넌트 등록 시스템
- [ ] 렌더 패스 등록 시스템
- [ ] 이벤트 시스템

#### 3단계: 플러그인 핫 리로드 (1-2일)
- [ ] 파일 감시 (FileWatcher)
- [ ] 자동 재빌드
- [ ] 플러그인 언로드/재로드
- [ ] 상태 보존 (플러그인 레벨)

#### 4단계: 예제 플러그인 (1일)
- [ ] `HelloWorldPlugin` (기본 예제)
- [ ] `GameplayPlugin` (게임 로직)
- [ ] `DebugPlugin` (디버그 렌더링)

#### 5단계: AI Digest 시스템 (2-3일)
- [ ] Digest 명령 파일 포맷 정의
- [ ] 플러그인 코드 분석 도구
- [ ] 엔진 코드 생성 템플릿
- [ ] 자동화 스크립트
- [ ] 통합 검증 파이프라인

---

## 기존 코드 처리

### Phase 2A 코드 (EngineWatcher, bin-hot 전략)
- ❌ **제거**: 엔진 핫 리로드 관련 코드
- ✅ **재사용**: FileWatcher 로직 → 플러그인 감시로 전환
- ✅ **재사용**: ALC 관련 코드 → 플러그인 격리로 전환

### 마이그레이션
```csharp
// Before (Phase 2A)
engineWatcher.WatchEngine("src/IronRose.Engine");

// After (Phase 2B)
pluginManager.WatchPlugin("Game/Plugins/GameplayPlugin");
```

---

## 결론

### 전략 변경 승인 여부: ✅ **승인 권장**

**이유**:
1. **더 실용적**: 엔진 핫 리로드의 복잡도 회피
2. **더 안정적**: 엔진 코어 안정성 유지
3. **더 빠른 개발**: 플러그인 핫 리로드가 더 빠름
4. **더 확장 가능**: 모듈러 아키텍처
5. **AI 워크플로우 최적화**: 실험 → 검증 → 통합 파이프라인

### 다음 액션
1. **Progress.md 업데이트**
   - Phase 2A를 Phase 2B로 재정의
   - 새로운 로드맵 반영

2. **문서 업데이트**
   - [Phase2_HotReloading.md](Phase2_HotReloading.md) → Phase2_PluginSystem.md로 리네임
   - 플러그인 시스템 설계 문서 작성

3. **코드 정리**
   - EngineWatcher 관련 코드 제거 또는 플러그인용으로 전환
   - bin-hot 전략 제거

4. **구현 시작**
   - `IEnginePlugin` 인터페이스부터 시작
   - 단계별 구현 및 검증

---

## 추가 고려사항

### 1. 플러그인 격리 수준
```
옵션 A: 완전 격리 (각 플러그인 별도 ALC)
- 장점: 플러그인 간 독립성
- 단점: 메모리 오버헤드, 플러그인 간 통신 복잡

옵션 B: 공유 ALC (모든 플러그인 하나의 ALC)
- 장점: 낮은 오버헤드, 간단한 통신
- 단점: 한 플러그인 크래시가 다른 플러그인 영향

권장: 옵션 B (초기 단순성 우선, 필요시 옵션 A로 확장)
```

### 2. 플러그인 의존성 관리
```csharp
// 플러그인이 다른 플러그인에 의존하는 경우
[DependsOn(typeof(CorePlugin))]
public class GameplayPlugin : IEnginePlugin
{
    // ...
}
```

### 3. 플러그인 버전 관리
```json
{
  "plugin": "Gameplay",
  "version": "1.0.0",
  "engine_version": "0.1.0",
  "dependencies": [
    {"plugin": "Core", "version": ">=1.0.0"}
  ]
}
```
